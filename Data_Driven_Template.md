## Data Driven Templates

Templates are the core structure that we know a function must have, independent of the details of its definition. In many cases the template for a function is determined by the type of data the function consumes. We refer to these as data driven templates. The recipe below can be used to produce a data driven template for any type comment.

For a given type TypeName the data driven template is:

```
(define (fn-for-type-name x)
  <body>)
```
Where x is an appropriately chosen parameter name (often the initials of the type name) and the body is determined according to the table below. To use the table, start with the type of the parameter, i.e. TypeName, and select the row of the table that matches that type. The first row matches only primitive types, the later rows match parts of type comments.

| Type of data                                                 | `cond` question (if applicable)                              | Body or `cond` answer (if applicable)                        |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **Atomic Non-Distinct** `Number` `String` `Boolean` `Image` interval like `Number[0, 10)` etc. | Appropriate predicate `(number? x)` `(string? x)` `(boolean? x)` `(image? x)` `(and (<= 0 x)`  `   (< x 10))` etc. | Expression that operates on the parameter. `(... x)`         |
| **Atomic Distinct Value** `"red"` `false` `empty` etc.       | Appropriate predicate <br><ul> <li>`(string=? x "red")`</li><li>`(false? x)`</li> <li>`(empty? x)`</li> <li>etc.</li></ul> | Since value is distinct, parameter does not appear. `(...)`  |
| **One Of** enumerations itemizations                         |                                                              | Cond with one clause per subclass of one of. `(cond [ ]` `   [ ])` Where each question and answer expression is formed by following the  rule in the question or answer column of this table for the  corresponding case. A detailed derivation of a template for a one-of  type appears below. It is permissible to use `else` for the last question for itemizations and large enumerations. Normal enumerations should not use else. Note that in a *mixed data itemization*, such as `;; Measurement is one of:`  `;; - Number[-10, 0)`  `;; - true`  `;; - Number(0, 10]` the cond questions must be **guarded** with an appropriate type predicate. In particular, the first cond question for `Measurement` must be `(and (number? m)`  `   (<= -10 m)`  `   (< m 0))` where the call to `number?` guards the calls to `<=` and `<`. This will protect `<=` and `<` from ever receiving true as an argument. |
| **Compound** `Position` `Firework` `Ball` cons etc.          | Predicate from structure `(posn? x)` `(firework? x)` `(ball? x)` `(cons? x)` (often just else) etc. | All selectors. `(... (posn-x x) (posn-y x))` `(... (firework-y x) (firework-color x))` `(... (ball-x x) (ball-dx x))` `(... (first x) (rest x))` etc.   Then consider the result type of each selector call and wrap the  accessor expression appropriately using the table with that type. So for example, if after adding all the selectors you have: `(... (game-ball g) ;produces Ball`  `   (game-paddle g)) ;produces Paddle` Then, because both Ball and Paddle are non-primitive types (types  that you yourself defined in a data definition) the reference rule  (immediately below) says that you should add calls to those types'  template functions as follows: ` (... (fn-for-ball (game-ball g))`  `   (fn-for-paddle (game-paddle g)))` |
| **Other Non-Primitive Type Reference**                       | Predicate, usually from structure definition `(firework? x)` `(person? x)` | Call to other type's template function `(fn-for-firework x)` `(fn-for-person x)` |
| **Self Reference**                                           |                                                              | Form natural recursion with call to this type's template function: `(fn-for-los (rest los))` |
| **Mutual Reference**   Note: form and group all templates in mutual reference cycle together. |                                                              | Call to other type's template function: `(fn-for-lod (dir-subdirs d)`  `(fn-for-dir (first lod))` |
